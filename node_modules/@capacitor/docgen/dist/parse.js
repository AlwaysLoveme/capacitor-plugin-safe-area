"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = void 0;
const typescript_1 = __importDefault(require("typescript"));
const transpile_1 = require("./transpile");
const github_slugger_1 = __importDefault(require("github-slugger"));
/**
 * Given either a tsconfig file path, or exact input files, will
 * use TypeScript to parse apart the source file's JSDoc comments
 * and returns a function which can be used to get a specific
 * interface as the primary api. Used by the generate() function.
 */
function parse(opts) {
    const tsProgram = transpile_1.getTsProgram(opts);
    const typeChecker = tsProgram.getTypeChecker();
    const tsSourceFiles = tsProgram.getSourceFiles();
    const interfaces = [];
    const enums = [];
    tsSourceFiles.forEach(tsSourceFile => {
        parseSourceFile(tsSourceFile, typeChecker, interfaces, enums);
    });
    return (api) => {
        const apiInterface = interfaces.find(i => i.name === api) || null;
        const data = {
            api: apiInterface,
            interfaces: [],
            enums: [],
        };
        if (apiInterface) {
            collectInterfaces(data, apiInterface, interfaces, enums);
        }
        return data;
    };
}
exports.parse = parse;
function collectInterfaces(data, i, interfaces, enums) {
    var _a;
    if (i.name !== ((_a = data.api) === null || _a === void 0 ? void 0 : _a.name) &&
        !data.interfaces.some(di => di.name === i.name)) {
        data.interfaces.push(i);
    }
    i.methods.forEach(m => {
        collectUsed(data, m.complexTypes, interfaces, enums);
    });
    i.properties.forEach(p => {
        collectUsed(data, p.complexTypes, interfaces, enums);
    });
}
function collectUsed(data, complexTypes, interfaces, enums) {
    complexTypes.forEach(typeName => {
        const fi = interfaces.find(i => i.name === typeName);
        if (fi && !data.interfaces.some(i => i.name === fi.name)) {
            collectInterfaces(data, fi, interfaces, enums);
        }
        const ei = enums.find(i => i.name === typeName);
        if (ei) {
            if (!data.enums.some(en => en.name === ei.name)) {
                data.enums.push(ei);
            }
        }
    });
}
function parseSourceFile(tsSourceFile, typeChecker, interfaces, enums) {
    const statements = tsSourceFile.statements;
    const interfaceDeclarations = statements.filter(typescript_1.default.isInterfaceDeclaration);
    const enumDeclarations = statements.filter(typescript_1.default.isEnumDeclaration);
    interfaceDeclarations.forEach(interfaceDeclaration => {
        interfaces.push(getInterface(typeChecker, interfaceDeclaration));
    });
    enumDeclarations.forEach(enumDeclaration => {
        enums.push(getEnum(typeChecker, enumDeclaration));
    });
}
function getInterface(typeChecker, node) {
    const interfaceName = node.name.text;
    const methods = node.members
        .filter(typescript_1.default.isMethodSignature)
        .reduce((methods, methodSignature) => {
        const m = getInterfaceMethod(typeChecker, methodSignature);
        if (m) {
            methods.push(m);
        }
        return methods;
    }, []);
    const properties = node.members
        .filter(typescript_1.default.isPropertySignature)
        .reduce((properties, properytSignature) => {
        const p = getInterfaceProperty(typeChecker, properytSignature);
        if (p) {
            properties.push(p);
        }
        return properties;
    }, []);
    const symbol = typeChecker.getSymbolAtLocation(node.name);
    const docs = symbol ? serializeSymbol(typeChecker, symbol) : null;
    const i = {
        name: interfaceName,
        slug: slugify(interfaceName),
        docs: (docs === null || docs === void 0 ? void 0 : docs.docs) || '',
        tags: (docs === null || docs === void 0 ? void 0 : docs.tags) || [],
        methods,
        properties,
    };
    return i;
}
function getEnum(typeChecker, node) {
    const enumName = node.name.text;
    const en = {
        name: enumName,
        slug: slugify(enumName),
        members: node.members.map(enumMember => {
            var _a;
            const symbol = typeChecker.getSymbolAtLocation(enumMember.name);
            const docs = symbol ? serializeSymbol(typeChecker, symbol) : null;
            const em = {
                name: enumMember.name.getText(),
                value: (_a = enumMember.initializer) === null || _a === void 0 ? void 0 : _a.getText(),
                tags: (docs === null || docs === void 0 ? void 0 : docs.tags) || [],
                docs: (docs === null || docs === void 0 ? void 0 : docs.docs) || '',
            };
            return em;
        }),
    };
    return en;
}
function getInterfaceMethod(typeChecker, methodSignature) {
    const flags = typescript_1.default.TypeFormatFlags.WriteArrowStyleSignature |
        typescript_1.default.TypeFormatFlags.NoTruncation;
    const signature = typeChecker.getSignatureFromDeclaration(methodSignature);
    if (!signature) {
        return null;
    }
    const returnType = typeChecker.getReturnTypeOfSignature(signature);
    const returnTypeNode = typeChecker.typeToTypeNode(returnType, methodSignature, typescript_1.default.NodeBuilderFlags.NoTruncation | typescript_1.default.NodeBuilderFlags.NoTypeReduction);
    const returnString = typeToString(typeChecker, returnType);
    const signatureString = typeChecker.signatureToString(signature, methodSignature, flags, typescript_1.default.SignatureKind.Call);
    const referencedTypes = new Set([
        ...getAllTypeReferences(returnTypeNode),
        ...getAllTypeReferences(methodSignature),
    ]);
    referencedTypes.delete('Promise');
    const methodName = methodSignature.name.getText();
    const m = {
        name: methodName,
        signature: signatureString,
        parameters: signature.parameters.map(symbol => {
            const doc = serializeSymbol(typeChecker, symbol);
            const type = typeChecker.getTypeAtLocation(symbol.valueDeclaration);
            const param = {
                name: symbol.name,
                docs: doc.docs,
                type: typeToString(typeChecker, type),
            };
            return param;
        }),
        returns: returnString,
        tags: signature.getJsDocTags(),
        docs: typescript_1.default.displayPartsToString(signature.getDocumentationComment(typeChecker)),
        complexTypes: Array.from(referencedTypes),
        slug: slugify(methodName),
    };
    return m;
}
function getInterfaceProperty(typeChecker, properytSignature) {
    const symbol = typeChecker.getSymbolAtLocation(properytSignature.name);
    if (!symbol) {
        return null;
    }
    const type = typeChecker.getTypeAtLocation(properytSignature);
    const docs = serializeSymbol(typeChecker, symbol);
    const referencedTypes = new Set(getAllTypeReferences(properytSignature));
    referencedTypes.delete('Promise');
    const propName = properytSignature.name.getText();
    const p = {
        name: propName,
        tags: docs.tags,
        docs: docs.docs,
        complexTypes: Array.from(referencedTypes),
        type: typeToString(typeChecker, type),
    };
    return p;
}
function typeToString(checker, type) {
    const TYPE_FORMAT_FLAGS = typescript_1.default.TypeFormatFlags.NoTruncation |
        typescript_1.default.TypeFormatFlags.InTypeAlias |
        typescript_1.default.TypeFormatFlags.InElementType;
    return checker.typeToString(type, undefined, TYPE_FORMAT_FLAGS);
}
function serializeSymbol(checker, symbol) {
    if (!checker || !symbol) {
        return {
            tags: [],
            docs: '',
        };
    }
    return {
        tags: symbol
            .getJsDocTags()
            .map(tag => ({ text: tag.text, name: tag.name })),
        docs: typescript_1.default.displayPartsToString(symbol.getDocumentationComment(checker)),
    };
}
function getAllTypeReferences(node) {
    const referencedTypes = [];
    const visit = (node) => {
        if (typescript_1.default.isTypeReferenceNode(node)) {
            referencedTypes.push(getEntityName(node.typeName));
            if (node.typeArguments) {
                node.typeArguments.filter(typescript_1.default.isTypeReferenceNode).forEach(tr => {
                    const typeName = tr.typeName;
                    if (typeName && typeName.escapedText) {
                        referencedTypes.push(typeName.escapedText.toString());
                    }
                });
            }
        }
        return typescript_1.default.forEachChild(node, visit);
    };
    if (node) {
        visit(node);
    }
    return Array.from(referencedTypes);
}
function getEntityName(entity) {
    if (typescript_1.default.isIdentifier(entity)) {
        return entity.escapedText.toString();
    }
    else {
        return getEntityName(entity.left);
    }
}
function slugify(id) {
    const s = new github_slugger_1.default();
    return s.slug(id);
}
